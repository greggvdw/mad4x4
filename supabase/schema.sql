-- Minimal schema (same as earlier build, condensed for brevity)
create table if not exists public.profiles (id uuid primary key references auth.users on delete cascade, email text unique, full_name text, role text check (role in ('admin','member','pending')) default 'pending', created_at timestamptz default now());
create table if not exists public.memberships (id bigserial primary key, user_id uuid references public.profiles(id) on delete cascade, status text check (status in ('active','lapsed','cancelled')) default 'lapsed', start_date date, end_date date, created_at timestamptz default now());
create table if not exists public.events (id bigserial primary key, title text not null, description text, start_time timestamptz not null, end_time timestamptz, location text, capacity int, status text check (status in ('draft','published','closed')) default 'published', event_type text check (event_type in ('meeting','trip','other')) default 'trip', created_by uuid references public.profiles(id), created_at timestamptz default now());
create table if not exists public.registrations (id bigserial primary key, event_id bigint references public.events(id) on delete cascade, user_id uuid references public.profiles(id) on delete cascade, status text check (status in ('registered','waitlisted','cancelled')) default 'registered', created_at timestamptz default now(), unique(event_id,user_id));
create table if not exists public.documents (id bigserial primary key, title text not null, url text not null, visibility text check (visibility in ('public','members')) default 'members', category text check (category in ('minutes','policy','general')) default 'general', uploaded_by uuid references public.profiles(id), uploaded_at timestamptz default now());
create table if not exists public.payments (id bigserial primary key, user_id uuid references public.profiles(id) on delete set null, amount_cents int not null, currency text default 'AUD', purpose text check (purpose in ('membership_renewal','event_fee')) not null, stripe_session_id text unique, status text check (status in ('pending','paid','failed')) default 'pending', created_at timestamptz default now());
create table if not exists public.attendance (id bigserial primary key, event_id bigint references public.events(id) on delete cascade, user_id uuid references public.profiles(id) on delete cascade, attended boolean default true, created_at timestamptz default now(), unique(event_id,user_id));
create table if not exists public.sign_on_forms (id bigserial primary key, event_id bigint references public.events(id) on delete cascade, user_id uuid references public.profiles(id) on delete set null, full_name text not null, email text, phone text, vehicle_rego text, passengers text, emergency_contact text, medical_info text, acknowledgement boolean default false, payload jsonb, created_at timestamptz default now());
alter table public.profiles enable row level security; alter table public.memberships enable row level security; alter table public.events enable row level security; alter table public.registrations enable row level security; alter table public.documents enable row level security; alter table public.payments enable row level security; alter table public.attendance enable row level security; alter table public.sign_on_forms enable row level security;
create policy "profiles_self_select" on public.profiles for select using (auth.uid() = id or exists(select 1 from public.profiles p where p.id = auth.uid() and p.role = 'admin')); create policy "profiles_self_update" on public.profiles for update using (auth.uid() = id);
create policy "events_public_read" on public.events for select using (status = 'published'); create policy "events_member_read_all" on public.events for select using (exists(select 1 from public.profiles p where p.id = auth.uid() and p.role in ('member','admin'))); create policy "events_admin_write" on public.events for all using (exists(select 1 from public.profiles p where p.id = auth.uid() and p.role = 'admin'));
create policy "registrations_member" on public.registrations for select using (user_id = auth.uid()); create policy "registrations_member_insert" on public.registrations for insert with check (user_id = auth.uid()); create policy "registrations_admin_read" on public.registrations for select using (exists(select 1 from public.profiles p where p.id = auth.uid() and p.role = 'admin'));
create policy "documents_public" on public.documents for select using (visibility = 'public'); create policy "documents_members" on public.documents for select using (exists(select 1 from public.profiles p where p.id = auth.uid() and p.role in ('member','admin'));
create policy "payments_self" on public.payments for select using (user_id = auth.uid()); create policy "payments_admin" on public.payments for select using (exists(select 1 from public.profiles p where p.id = auth.uid() and p.role = 'admin'));
create policy "attendance_member_self" on public.attendance for select using (user_id = auth.uid()); create policy "attendance_admin" on public.attendance for all using (exists(select 1 from public.profiles p where p.id = auth.uid() and p.role = 'admin'));
create policy "signon_self" on public.sign_on_forms for select using (user_id = auth.uid() or user_id is null); create policy "signon_insert_self" on public.sign_on_forms for insert with check (user_id = auth.uid() or user_id is null); create policy "signon_admin" on public.sign_on_forms for all using (exists(select 1 from public.profiles p where p.id = auth.uid() and p.role = 'admin'));
create or replace function public.enforce_event_capacity() returns trigger as $$ declare cap int; current_reg int; begin select capacity into cap from public.events where id = new.event_id; if cap is null or cap <= 0 then return new; end if; select count(*) into current_reg from public.registrations where event_id = new.event_id and status = 'registered'; if current_reg >= cap then new.status := 'waitlisted'; end if; return new; end; $$ language plpgsql security definer; drop trigger if exists trg_enforce_capacity on public.registrations; create trigger trg_enforce_capacity before insert on public.registrations for each row execute procedure public.enforce_event_capacity();
create or replace function public.promote_from_waitlist(p_event_id bigint) returns void as $$ declare cap int; current_reg int; promote_id bigint; begin select capacity into cap from public.events where id = p_event_id; if cap is null or cap <= 0 then return; end if; select count(*) into current_reg from public.registrations where event_id = p_event_id and status = 'registered'; if current_reg < cap then select id into promote_id from public.registrations where event_id = p_event_id and status = 'waitlisted' order by created_at asc limit 1; if promote_id is not null then update public.registrations set status = 'registered' where id = promote_id; end if; end if; end; $$ language plpgsql security definer;
create or replace view public.eligibility_candidates as select pr.id as user_id, coalesce(pr.full_name, pr.email) as name, pr.email, sum(case when e.event_type='meeting' and a.attended then 1 else 0 end) as meetings_attended, sum(case when e.event_type='trip' and a.attended then 1 else 0 end) as trips_attended, (sum(case when e.event_type='meeting' and a.attended then 1 else 0 end) >= 1 and sum(case when e.event_type='trip' and a.attended then 1 else 0 end) >= 2) as eligible from public.profiles pr left join public.attendance a on a.user_id=pr.id left join public.events e on e.id=a.event_id where pr.role in ('pending','member','admin') group by pr.id, pr.full_name, pr.email;
create or replace function public.set_member_role(p_user uuid, p_role text) returns void as $$ begin if not exists (select 1 from public.profiles p where p.id = auth.uid() and p.role = 'admin') then raise exception 'Only admin can change roles'; end if; update public.profiles set role = p_role where id = p_user; end; $$ language plpgsql security definer;
